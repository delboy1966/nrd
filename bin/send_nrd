#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Std;
use IO::Socket;
use NRD::Packet;
use NRD::Serialize;

my %opts;
getopts('c:', \%opts) || die "Incorrect options";
my $conf_file = $opts{'c'} || '/etc/send_nrd.cfg';
my ($host, $port);
my $conf = {};
{
  local *CONF;
  open CONF, "<", $conf_file or next;
  while (my $line = <CONF>){
    chomp $line;
    next if ($line =~ m/^\s*#/);
    next if ($line =~ m/^\s*$/);
    $line =~ s/^\s*(\w+)\s+(.{1,}?)\s*$/$conf->{$1} = $2;/ge;
  }
}

$host = $conf->{'host'} ||= 'localhost';
$port = $conf->{'port'} ||= 5669;

$conf->{'serializer'}   ||= 'none';
$conf->{'encrypt_type'} ||= '';
$conf->{'encrypt_key'}  ||= '';

#
#use Data::Dumper;
#print Dumper($conf, $host, $port);
#
my $serializer = NRD::Serialize->instance_of(lc($conf->{'serializer'}), $conf);

my $sock = IO::Socket::INET->new(PeerAddr => $host,
                                 PeerPort => $port,
                                 Proto    => 'tcp',
                                 ) || die "Can't connect [$!]";
$sock->autoflush(1);

my $packer = NRD::Packet->new();
if ($serializer->needs_helo){
  print $sock $packer->pack($serializer->helo);
}

while (my $line = <STDIN>){
  chomp $line;
  my $r = {
    'command' => 'result',
    'data' => {
      'time' => time(),
      %{ $serializer->from_line($line) }
    },
  };
  print $sock $packer->pack($serializer->freeze($r));
}
print $sock $packer->pack($serializer->freeze( { 'command' => "commit" } ) );

my $response = $packer->unpack( $sock );
close $sock;

if (! defined $response) {
  print "No response from server\n";
  exit 1;
}

eval {
    $response = $serializer->unfreeze( $response );
};

if ($@) {
    print "Couldn't unserialize a request: $@";
    exit 1;
}

unless (ref $response eq "HASH" && exists $response->{command} && $response->{command} eq "finished") {
  require Data::Dump;
  print "Bad response from server: ".Data::Dump::dump($response)."\n";
  exit 1;
}

exit;
